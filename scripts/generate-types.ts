import * as path from 'path';
import * as fs from 'fs/promises';
import * as strongSoap from 'strong-soap';

const WSDL = strongSoap.soap.WSDL;

const SCHEMA_DIR = path.resolve(process.cwd(), 'schema');
const OUT_WSDL_SUPPORT = path.resolve(process.cwd(), 'src/types/generated/wsdl-support.ts');
const OUT_AXL_OBJECTS = path.resolve(process.cwd(), 'src/types/generated/axl-objects.ts');
const OUT_OBJECTS_JSON = path.resolve(process.cwd(), 'generated/axl-top-level-objects.json');

const TARGET_OPERATIONS = [
  // Phones
  'addPhone',
  'getPhone',
  'listPhone',
  'updatePhone',
  'removePhone',
  // App Users
  'addAppUser',
  'getAppUser',
  'listAppUser',
  'updateAppUser',
  'removeAppUser',
  // End Users
  'addUser',
  'getUser',
  'listUser',
  'updateUser',
  'removeUser',
  // Hunt Groups (Hunt Lists)
  'addHuntList',
  'getHuntList',
  'listHuntList',
  'updateHuntList',
  'removeHuntList',
  // Line Groups
  'addLineGroup',
  'getLineGroup',
  'listLineGroup',
  'updateLineGroup',
  'removeLineGroup',
  // Directory Numbers (Lines)
  'addLine',
  'getLine',
  'listLine',
  'updateLine',
  'removeLine',
] as const;

type TargetOperation = (typeof TARGET_OPERATIONS)[number];

type CrudVerb = 'add' | 'get' | 'list' | 'update' | 'remove';

async function openWsdl(wsdlPath: string): Promise<any> {
  return new Promise((resolve, reject) => {
    WSDL.open(
      wsdlPath,
      {
        attributesKey: 'attributes',
        valueKey: 'value',
      },
      (err: any, wsdl: any) => {
        if (err) reject(err);
        else resolve(wsdl);
      }
    );
  });
}

function extractOperationNames(wsdl: any): string[] {
  const defs = wsdl?.definitions;
  const service = defs?.services?.AXLAPIService;
  const port = service?.ports?.AXLPort;
  const bindingRef: unknown = port?.binding;
  if (!bindingRef) return [];

  let bindingName: string | undefined;
  if (typeof bindingRef === 'string') {
    bindingName = bindingRef.includes(':') ? bindingRef.split(':').pop() : bindingRef;
  } else if (typeof bindingRef === 'object' && bindingRef !== null) {
    const refObj = bindingRef as Record<string, unknown>;
    if (typeof refObj.$name === 'string') bindingName = refObj.$name;
    else if (typeof refObj.name === 'string') bindingName = refObj.name;
  }

  const binding =
    (bindingName && defs?.bindings?.[bindingName]) ||
    (typeof bindingRef === 'string' && defs?.bindings?.[bindingRef]) ||
    undefined;

  const operationsObj = binding?.operations;
  if (!operationsObj) return [];
  return Object.keys(operationsObj);
}

async function main() {
  const entries = await fs.readdir(SCHEMA_DIR, { withFileTypes: true });
  const versions = entries
    .filter(e => e.isDirectory())
    .map(e => e.name)
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

  const matrix: Record<string, Record<TargetOperation, boolean>> = {};
  const missingByVersion: Record<string, TargetOperation[]> = {};
  const operationsByVersion: Record<string, string[]> = {};

  for (const version of versions) {
    const wsdlPath = path.join(SCHEMA_DIR, version, 'AXLAPI.wsdl');
    const wsdl = await openWsdl(wsdlPath);
    const opsList = extractOperationNames(wsdl).sort();
    const ops = new Set(opsList);
    operationsByVersion[version] = opsList;

    const support: Record<TargetOperation, boolean> = {} as any;
    const missing: TargetOperation[] = [];

    for (const op of TARGET_OPERATIONS) {
      const ok = ops.has(op);
      support[op] = ok;
      if (!ok) missing.push(op);
    }

    matrix[version] = support;
    missingByVersion[version] = missing;
  }

  const missingAny = Object.entries(missingByVersion).filter(([, missing]) => missing.length > 0);
  if (missingAny.length > 0) {
    const lines = missingAny.map(([v, missing]) => `- ${v}: ${missing.join(', ')}`).join('\n');
    throw new Error(`WSDL missing required operations:\n${lines}`);
  }

  const wsdlSupportFile = `/* eslint-disable */
// AUTO-GENERATED by scripts/generate-types.ts. Do not edit by hand.

export const WSDL_VERSIONS = ${JSON.stringify(versions)} as const;
export type WsdlVersion = (typeof WSDL_VERSIONS)[number];

export const TARGET_AXL_OPERATIONS = ${JSON.stringify(TARGET_OPERATIONS)} as const;
export type TargetAxlOperation = (typeof TARGET_AXL_OPERATIONS)[number];

export const VERSION_SUPPORT_MATRIX = ${JSON.stringify(matrix, null, 2)} as const;
`;

  const latestVersion = versions[versions.length - 1];
  if (!latestVersion) throw new Error('No WSDL versions found under schema/');
  const latestOps = operationsByVersion[latestVersion] ?? [];

  const objectOps: Record<string, Partial<Record<CrudVerb, string>>> = {};
  const crudRegex = /^(add|get|list|update|remove)(.+)$/;
  for (const op of latestOps) {
    const match = op.match(crudRegex);
    if (!match) continue;
    const verb = match[1] as CrudVerb;
    const objectName = match[2];
    if (!objectName) continue;
    objectOps[objectName] ||= {};
    objectOps[objectName][verb] = op;
  }

  const objects = Object.keys(objectOps).sort((a, b) => a.localeCompare(b));
  const objectsJson = JSON.stringify({ version: latestVersion, objects }, null, 2);

  const axlObjectsFile = `/* eslint-disable */
// AUTO-GENERATED by scripts/generate-types.ts. Do not edit by hand.
// Source WSDL version: ${latestVersion}

export const AXL_OBJECTS_SOURCE_WSDL_VERSION = ${JSON.stringify(latestVersion)} as const;

export const AXL_TOP_LEVEL_OBJECTS = ${JSON.stringify(objects)} as const;
export type AxlTopLevelObject = (typeof AXL_TOP_LEVEL_OBJECTS)[number];

export type CrudVerb = 'add' | 'get' | 'list' | 'update' | 'remove';

export const AXL_OBJECT_OPERATIONS = ${JSON.stringify(objectOps, null, 2)} as const;
`;

  await fs.mkdir(path.dirname(OUT_WSDL_SUPPORT), { recursive: true });
  await fs.writeFile(OUT_WSDL_SUPPORT, wsdlSupportFile, 'utf8');

  await fs.mkdir(path.dirname(OUT_AXL_OBJECTS), { recursive: true });
  await fs.writeFile(OUT_AXL_OBJECTS, axlObjectsFile, 'utf8');

  await fs.mkdir(path.dirname(OUT_OBJECTS_JSON), { recursive: true });
  await fs.writeFile(OUT_OBJECTS_JSON, objectsJson, 'utf8');
}

main().catch(err => {
  console.error(String(err?.message ?? err));
  process.exit(1);
});
